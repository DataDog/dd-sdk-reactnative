/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

import org.apache.tools.ant.taskdefs.condition.Os
import java.util.regex.Matcher
import java.util.regex.Pattern

afterEvaluate {

    def androidExtension = extensions.findByName("android")

    if (androidExtension == null || android.applicationVariants == null) {
        throw new GradleException("Android extension is missing or running not in the application" +
                " module. Make sure you've applied datadog-sourcemaps.gradle in the" +
                " application module (usually it is located in the android/app/build.gradle file).")
    }

    androidExtension.applicationVariants.all { variant ->

        def releaseVersion = getVersionName(variant)

        def buildVersion = variant.versionCode

        if (releaseVersion == null) {
            throw new GradleException("Cannot determine application version. Make sure to" +
                    " define versionName property in the application/variant config.")
        }

        def reactConfig = getReactConfig(buildDir, variant)
        def targetName = reactConfig["targetName"]
        def targetPath = reactConfig["targetPath"]

        def reactRoot = file(reactConfig.root)

        def bundleTask = tasks.findByName(reactConfig.bundleTaskName)

        if (bundleTask == null) {
            logger.info("Cannot find JS bundle task for variant=${targetName}.")
            return
        }

        if (!bundleTask.enabled) {
            logger.info("JS bundle task for variant=${targetName} is not enabled.")
            return
        }

        def (bundleOutput, sourcemapOutput) = forceSourcemapsGenFromBundleTask(bundleTask)
        
        def serviceName = getServiceName(variant)
        logger.info("Release version used for the upload of variant=${targetName} is ${releaseVersion}.")
        logger.info("Service name used for the upload of variant=${targetName} is ${serviceName}.")

        def uploadTask = tasks.create("upload${targetName}Sourcemaps") {
            group = "datadog"
            description = "Uploads sourcemaps to Datadog."

            def execCommand = [
                    "${getDatadogCiExecPath(reactConfig)}",
                    "react-native",
                    "upload",
                    "--platform",
                    "android",
                    "--service",
                    serviceName,
                    "--bundle",
                    bundleOutput,
                    "--sourcemap",
                    sourcemapOutput,
                    "--release-version",
                    releaseVersion,
                    "--build-version",
                    buildVersion
            ]

            doFirst {
                runShellCommand(execCommand, reactRoot)
            }
        }

        uploadTask.dependsOn bundleTask
        bundleTask.finalizedBy uploadTask

    }
}

// Function to force the generation of a source map from the bundle task
private def forceSourcemapsGenFromBundleTask(bundleTask) {
    def taskProperties = bundleTask.getProperties()
    def cmdLine = taskProperties.get("commandLine") as List<String>
    def args = taskProperties.get("args") as List<String>

    def (outputBundle, outputSourceMap) = getBundleTaskArguments(bundleTask, args)

    // Override 'outputBundle' path if 'DATADOG_BUNDLE_OUTPUT' environment variable is set
    def envOutputBundle = System.getenv('DATADOG_BUNDLE_OUTPUT')
    if (envOutputBundle != null) {
        project.logger.info("Overriding bundle output path with DATADOG_BUNDLE_OUTPUT=${envOutputBundle}")
        outputBundle = new File(envOutputBundle)
    }

    // Override 'outputSourceMap' path if 'DATADOG_SOURCEMAP_OUTPUT' environment variable is set
    def envOutputSourceMap = System.getenv('DATADOG_SOURCEMAP_OUTPUT')
    if (envOutputSourceMap != null) {
        project.logger.info("Overriding source map output path with DATADOG_SOURCEMAP_OUTPUT=${envOutputSourceMap}")
        outputSourceMap = new File(envOutputSourceMap)
    }

    if (outputSourceMap == null) {
        outputSourceMap = outputBundle + ".map"

        cmdLine.addAll(["--sourcemap-output", outputSourceMap])
        args.addAll(["--sourcemap-output", outputSourceMap])

        bundleTask.setProperty("commandLine", cmdLine)
        bundleTask.setProperty("args", args)

        project.logger.info("Forced source map output for `${bundleTask.name}` task")
    } else {
        project.logger.info("Using source map file: ${outputSourceMap}")
    }

    return [outputBundle, outputSourceMap]
}

// Function to get bundle task arguments
private def getBundleTaskArguments(bundleTask, args) {
    def (outputBundle, outputSourceMap) = retrieveBundleTaskArgs(bundleTask)
    if (outputBundle == null) {
        (outputBundle, outputSourceMap) = retrieveBundleTaskArgsLegacy(args)
    }
    return [outputBundle, outputSourceMap]
}

// Function to retrieve bundle task arguments for React Native 71 and above
private def retrieveBundleTaskArgs(bundleTask) {
    def taskProperties = bundleTask.getProperties()
    def bundleFileName = taskProperties.bundleAssetName?.get()

    if (bundleFileName == null) {
        return [null, null]
    }

    def jsBundleFile = new File(taskProperties.jsBundleDir.get().asFile.absolutePath, bundleFileName)
    def jsSourceMapFile = new File(taskProperties.jsSourceMapsDir.get().asFile.absolutePath, "${bundleFileName}.map")

    project.logger.info("jsBundleFile: `${jsBundleFile}`")
    project.logger.info("jsSourceMapFile: `${jsSourceMapFile}`")
    return [jsBundleFile, jsSourceMapFile]
}

// Function to retrieve legacy bundle task arguments
private def retrieveBundleTaskArgsLegacy(args) {
    def outputBundle = null
    def outputSourceMap = null

    args.eachWithIndex { String argument, int index ->
        if (argument == "--bundle-output") {
            outputBundle = args[index + 1]
            project.logger.info("--bundle-output: `${outputBundle}`")
        } else if (argument == "--sourcemap-output") {
            outputSourceMap = args[index + 1]
            project.logger.info("--sourcemap-output param: `${outputSourceMap}`")
        }
    }

    // Check and correct paths if Hermes is enabled
    def hermesEnabled = project.ext.react.get("enableHermes", false);
    project.logger.info("Hermes enabled: `${hermesEnabled}`")

    if (outputBundle != null && outputSourceMap != null && hermesEnabled) {
        def pattern = Pattern.compile("(/|\\\\)intermediates\\1sourcemaps\\1react\\1")
        Matcher matcher = pattern.matcher(outputSourceMap)
        if (matcher.find()) {
            project.logger.info("Correcting path for sourcemapOutput.")
            outputSourceMap = outputBundle.replaceAll("(/|\\\\)generated\\1assets\\1react\\1", "\$1generated\$1sourcemaps\$1react\$1") + ".map"
            project.logger.info("New sourcemapOutput path: `${outputSourceMap}`")
        }
    }

    return [outputBundle, outputSourceMap]
}


/**
 * We use a function here to resolve the datadog-ci executable path.
 * If DATADOG_CI_EXEC env variable is defined, it will be returned (if valid).
 */
private def getDatadogCiExecPath(reactConfig) {
    def defaultPath = "${reactConfig.root}/node_modules/.bin/datadog-ci"

    // Try to retrieve the path from ENV variable
    def envPath = System.getenv('DATADOG_CI_EXEC')
    if (envPath != null) {
        if (isValidDatadogCiExec(envPath)) {
            return envPath
        } else {
            println("WARNING: Ignoring DATADOG_CI_EXEC as it does not point to a valid datadog-ci executable")
        }
    }

    def nodeExecutable = Os.isFamily(Os.FAMILY_WINDOWS) ? 'node.exe' : 'node'
    def nodeScript = '''
    const path = require('path');
    const modulePath = require.resolve('@datadog/datadog-ci/package.json');
    const nodeModulesDir = path.resolve(path.dirname(modulePath), '../../');
    const datadogCiExec = path.join(nodeModulesDir, '.bin', 'datadog-ci');
    console.log(datadogCiExec);
    '''

    def stdout = new ByteArrayOutputStream()
    def process = new ProcessBuilder(nodeExecutable)
            .redirectErrorStream(true)
            .start()

    process.outputStream.withWriter { writer ->
        writer << nodeScript
    }

    process.inputStream.eachLine { line ->
        stdout << line << '\n'
    }
    
    process.waitFor()

    def resolvedPath = stdout.toString().trim()
    if (isValidDatadogCiExec(resolvedPath)) {
        return resolvedPath
    } else {
        println("WARNING: Could not resolve datadog-ci executable path, falling back to default: ${defaultPath}")
    }

    return defaultPath
}

/**
 * Function to validate datadog-ci executable path.
 */
private def isValidDatadogCiExec(String path) {
    def file = new File(path)
    if (!file.exists() || !file.canExecute()) {
        return false
    }
    
    return true
}

/**
 * We use a function here to resolve the correct bundle location after the bundle task
 * is over, as its location can depend on the Android Gradle Plugin version.
 */
private def getBundleFileResolver(String[] jsBundleDirs, String bundleAssetName) {
    def resolver = { ->
        return jsBundleDirs.collect {
            file("$it/$bundleAssetName")
        }.find {
            it.exists()
        }
    }

    return resolver
}

/** 
 * From RN 0.71, the following things changed in the RN gradle plugin:
 * - bundle task name changed from "bundle${targetName}JsAndAssets" to "createBundle${targetName}JsAndAssets"
 * - bundle dir changed from "$buildDir/generated/assets/react/${targetPath}" to "$buildDir/ASSETS/createBundle${targetName}JsAndAssets"
 *   (and then "$buildDir/generated/assets/createBundle${targetPath}JsAndAssets" with the release of Android Gradle Plugin 7.4, see https://github.com/facebook/react-native/issues/35439)
 * - config was in "project.react" and is now in "project.extensions.react"
 * - accessing parameters values requires calling a getter 
 * - target path changed from variant.dirName to variant.name
 */
private def getReactConfig(File buildDir, variant) {
    def reactConfig = [:]

    if (project.extensions.findByName("react")) {
        // From RN 0.71
        // Locations and names are defined in "node_modules/react-native-gradle-plugin/src/main/kotlin/com/facebook/react/TaskConfiguration.kt"
        def bundleAssetName = project.extensions.react.bundleAssetName.get() ?: "index.android.bundle"
        def targetName = variant.name.capitalize()
        def targetPath = variant.name
        reactConfig['bundleTaskName'] = "createBundle${targetName}JsAndAssets"
        reactConfig['bundleFileResolver'] = getBundleFileResolver([
            "$buildDir/ASSETS/createBundle${targetName}JsAndAssets", // Android Gradle Plugin 7.3
            "$buildDir/generated/assets/createBundle${targetName}JsAndAssets" // Android Gradle Plugin 7.4 and up
        ] as String[], bundleAssetName)
        reactConfig['bundleAssetName'] = bundleAssetName
        reactConfig['targetPath'] = targetPath
        reactConfig['targetName'] = targetName
        reactConfig['root'] = project.extensions.react.root.get() ?: "../../"
    } else if (project.hasProperty("react")) {
        // WARNING: on RN 0.71, `project.react` is an empty map, so this `if` must go after the previous one.
        // Legacy way, before RN 0.71
        // Locations and names are defined in "node_modules/react-native/react.gradle"
        def targetName = variant.name.capitalize()
        def targetPath = variant.dirName
        def bundleAssetName = project.react.bundleAssetName ?: "index.android.bundle"
        reactConfig['bundleTaskName'] = "bundle${targetName}JsAndAssets"
        reactConfig['bundleFileResolver'] = getBundleFileResolver(["$buildDir/generated/assets/react/${targetPath}"] as String[], bundleAssetName)
        reactConfig['bundleAssetName'] = bundleAssetName
        reactConfig['targetPath'] = targetPath
        reactConfig['targetName'] = targetName
        reactConfig['root'] = project.react.root ?: "../../"
    } else {
        // We assume this cannot happen with RN >= 0.71, so we use the legacy default values
        // Locations and names are defined in "node_modules/react-native/react.gradle"
        def targetName = variant.name.capitalize()
        def targetPath = variant.dirName
        def bundleAssetName = "index.android.bundle"
        reactConfig['bundleTaskName'] = "bundle${targetName}JsAndAssets"
        reactConfig['bundleFileResolver'] = getBundleFileResolver(["$buildDir/generated/assets/react/${targetPath}"] as String[], bundleAssetName)
        reactConfig['bundleAssetName'] = bundleAssetName
        reactConfig['targetPath'] = targetPath
        reactConfig['targetName'] = targetName
        reactConfig['root'] = "../../"
    }

    return reactConfig
}

private def runShellCommand(
        List<String> command,
        File workingDirectory
) {
    def outputStream = new ByteArrayOutputStream()
    def errorStream = new ByteArrayOutputStream()

    try {
        def result = exec {
            workingDir = workingDirectory
            standardOutput = outputStream
            errorOutput = errorStream
            if (Os.isFamily(Os.FAMILY_WINDOWS)) {
                commandLine("cmd", "/c", *command)
            } else {
                commandLine(*command)
            }
        }

        if (result.exitValue != 0) {
            logger.error(errorStream.toString("UTF-8"))
            result.rethrowFailure()
        } else {
            logger.lifecycle(outputStream.toString("UTF-8"))
        }
    } catch (Exception e) {
        def errorStreamContent = errorStream.toString("UTF-8")
        def standardStreamContent = outputStream.toString("UTF-8")
        logger.error("Exception raised during command execution," +
                " stderr=${errorStreamContent}, stdout=${standardStreamContent}")
        throw e
    }
}

private def getServiceName(variant) {
    if (project.hasProperty("datadog") && project.datadog.hasProperty("serviceName")) {
        if (project.datadog.serviceName) {
            return project.datadog.serviceName
        }
    }
    return variant.applicationId
}

private def getVersionName(variant) {
    def envVersionName = System.getenv('DATADOG_RELEASE_VERSION')
    if (envVersionName != null) {
        return envVersionName;
    }

    return variant.versionName
}